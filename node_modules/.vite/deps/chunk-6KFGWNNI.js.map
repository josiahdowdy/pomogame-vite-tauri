{
  "version": 3,
  "sources": ["../../vuetify/src/composables/density.ts", "../../vuetify/src/composables/rounded.ts", "../../vuetify/src/composables/proxiedModel.ts"],
  "sourcesContent": ["// Utilities\nimport { computed } from 'vue'\nimport { getCurrentInstanceName, propsFactory } from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\n\nconst allowedDensities = [null, 'default', 'comfortable', 'compact'] as const\n\nexport type Density = typeof allowedDensities[number]\n\nexport interface DensityProps {\n  density?: Density\n}\n\n// Composables\nexport const makeDensityProps = propsFactory({\n  density: {\n    type: String as PropType<Density>,\n    default: 'default',\n    validator: (v: any) => allowedDensities.includes(v),\n  },\n}, 'density')\n\nexport function useDensity (\n  props: DensityProps,\n  name = getCurrentInstanceName(),\n) {\n  const densityClasses = computed(() => {\n    return `${name}--density-${props.density}`\n  })\n\n  return { densityClasses }\n}\n", "// Utilities\nimport { computed, isRef } from 'vue'\nimport { getCurrentInstanceName, propsFactory } from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\ntype RoundedValue = boolean | string | number | null | undefined\n\nexport interface RoundedProps {\n  rounded?: RoundedValue\n  tile?: boolean\n}\n\ntype RoundedData = {\n  roundedClasses: Ref<string[]>\n}\n\n// Composables\nexport const makeRoundedProps = propsFactory({\n  rounded: {\n    type: [Boolean, Number, String],\n    default: undefined,\n  },\n}, 'rounded')\n\nexport function useRounded (\n  props: RoundedProps | Ref<RoundedValue>,\n  name = getCurrentInstanceName(),\n): RoundedData {\n  const roundedClasses = computed(() => {\n    const rounded = isRef(props) ? props.value : props.rounded\n    const classes: string[] = []\n\n    if (rounded === true || rounded === '') {\n      classes.push(`${name}--rounded`)\n    } else if (\n      typeof rounded === 'string' ||\n      rounded === 0\n    ) {\n      for (const value of String(rounded).split(' ')) {\n        classes.push(`rounded-${value}`)\n      }\n    }\n\n    return classes\n  })\n\n  return { roundedClasses }\n}\n", "// Utilities\nimport { computed, ref } from 'vue'\nimport { getCurrentInstance, toKebabCase } from '@/util'\n\n// Types\nimport type { Ref } from 'vue'\n\n// Composables\nexport function useProxiedModel<\n  Props extends object & { [key in Prop as `onUpdate:${Prop}`]: ((val: any) => void) | undefined },\n  Prop extends Extract<keyof Props, string>,\n  Inner = Props[Prop],\n> (\n  props: Props,\n  prop: Prop,\n  defaultValue?: Props[Prop],\n  transformIn: (value?: Props[Prop]) => Inner = (v: any) => v,\n  transformOut: (value: Inner) => Props[Prop] = (v: any) => v,\n) {\n  const vm = getCurrentInstance('useProxiedModel')\n\n  const propIsDefined = computed(() => {\n    return !!(\n      typeof props[prop] !== 'undefined' &&\n      (vm?.vnode.props?.hasOwnProperty(prop) || vm?.vnode.props?.hasOwnProperty(toKebabCase(prop)))\n    )\n  })\n\n  const internal = ref(transformIn(props[prop])) as Ref<Inner>\n\n  return computed<Inner extends any[] ? Readonly<Inner> : Inner>({\n    get (): any {\n      if (propIsDefined.value) return transformIn(props[prop])\n      else return internal.value\n    },\n    set (newValue) {\n      if ((propIsDefined.value ? transformIn(props[prop]) : internal.value) === newValue) {\n        return\n      }\n      internal.value = newValue\n      vm?.emit(`update:${prop}`, transformOut(newValue))\n    },\n  })\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAOA,IAAMA,mBAAmB,CAAC,MAAM,WAAW,eAAe,SAAjC;AASlB,IAAMC,mBAAmBC,aAAa;EAC3CC,SAAS;IACPC,MAAMC;IACNC,SAAS;IACTC,WAAYC,OAAWR,iBAAiBS,SAASD,CAA1B;EAHhB;AADkC,GAM1C,SANyC;AAQrC,SAASE,WACdC,OAEA;AAAA,MADAC,OACA,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KADOC,uBAAsB;AAE7B,QAAMC,iBAAiBC,SAAS,MAAM;AACpC,WAAQ,GAAEH,iBAAiBD,MAAMR;EAClC,CAF8B;AAI/B,SAAO;IAAEW;EAAF;AACR;;;ACdM,IAAME,mBAAmBC,aAAa;EAC3CC,SAAS;IACPC,MAAM,CAACC,SAASC,QAAQC,MAAlB;IACNC,SAASC;EAFF;AADkC,GAK1C,SALyC;AAOrC,SAASC,WACdC,OAEa;AAAA,MADbC,OACa,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KADNC,uBAAsB;AAE7B,QAAMC,iBAAiBC,SAAS,MAAM;AACpC,UAAMZ,UAAUa,MAAML,KAAD,IAAUA,MAAMM,QAAQN,MAAMR;AACnD,UAAMe,UAAoB,CAAA;AAE1B,QAAIf,YAAY,QAAQA,YAAY,IAAI;AACtCe,cAAQC,KAAM,GAAEP,eAAhB;IACD,WACC,OAAOT,YAAY,YACnBA,YAAY,GACZ;AACA,iBAAWc,SAASV,OAAOJ,OAAD,EAAUiB,MAAM,GAAtB,GAA4B;AAC9CF,gBAAQC,KAAM,WAAUF,OAAxB;MACD;IACF;AAED,WAAOC;EACR,CAhB8B;AAkB/B,SAAO;IAAEJ;EAAF;AACR;;;ACzCM,SAASO,gBAKdC,OACAC,MACAC,cAGA;AAAA,MAFAC,cAEA,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAF+CC,OAAWA;AAE1D,MADAC,eACA,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAD+CD,OAAWA;AAE1D,QAAME,KAAKC,mBAAmB,iBAAD;AAE7B,QAAMC,gBAAgBC,SAAS,MAAM;AAAA,QAAA,iBAAA;AACnC,WAAO,CAAC,EACN,OAAOT,MAAMC,UAAU,gBACtBK,MAAE,SAAF,kBAAAA,GAAII,MAAMV,UAAV,QAAA,gBAAiBW,eAAeV,IAAhC,KAAyCK,MAAzC,SAAA,mBAAyCA,GAAII,MAAMV,UAAnD,QAAyC,iBAAiBW,eAAeC,YAAYX,IAAD,CAA3C;EAE7C,CAL6B;AAO9B,QAAMY,WAAWC,IAAIX,YAAYH,MAAMC,KAAP,CAAZ;AAEpB,SAAOQ,SAAwD;IAC7DM,MAAY;AACV,UAAIP,cAAcQ;AAAO,eAAOb,YAAYH,MAAMC,KAAP;;AACtC,eAAOY,SAASG;IACtB;IACDC,IAAKC,UAAU;AACb,WAAKV,cAAcQ,QAAQb,YAAYH,MAAMC,KAAP,IAAgBY,SAASG,WAAWE,UAAU;AAClF;MACD;AACDL,eAASG,QAAQE;AACjBZ,YAAE,OAAF,SAAAA,GAAIa,KAAM,UAASlB,QAAQI,aAAaa,QAAD,CAAvC;IACD;EAX4D,CAAhD;AAahB;",
  "names": ["allowedDensities", "makeDensityProps", "propsFactory", "density", "type", "String", "default", "validator", "v", "includes", "useDensity", "props", "name", "getCurrentInstanceName", "densityClasses", "computed", "makeRoundedProps", "propsFactory", "rounded", "type", "Boolean", "Number", "String", "default", "undefined", "useRounded", "props", "name", "getCurrentInstanceName", "roundedClasses", "computed", "isRef", "value", "classes", "push", "split", "useProxiedModel", "props", "prop", "defaultValue", "transformIn", "v", "transformOut", "vm", "getCurrentInstance", "propIsDefined", "computed", "vnode", "hasOwnProperty", "toKebabCase", "internal", "ref", "get", "value", "set", "newValue", "emit"]
}
