import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/unified-network/lib/util.js
var require_util = __commonJS({
  "node_modules/unified-network/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPaths = void 0;
    function joinPaths(...paths) {
      let [first, ...rest] = paths;
      const cleanedRest = rest.map((it) => it.slice(it.startsWith("/") ? 1 : 0, it.endsWith("/") ? -1 : void 0));
      if (rest[rest.length - 1].endsWith("/")) {
        cleanedRest[cleanedRest.length - 1] = cleanedRest[cleanedRest.length - 1] + "/";
      }
      return [
        first.endsWith("/") ? first.slice(0, -1) : first,
        ...cleanedRest
      ].join("/");
    }
    exports.joinPaths = joinPaths;
  }
});

// node_modules/unified-network/lib/unified-network.js
var require_unified_network = __commonJS({
  "node_modules/unified-network/lib/unified-network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnifiedNetwork = void 0;
    var util_1 = require_util();
    async function httpProcessorFetch({ method, url, headers, body }) {
      var _a;
      let responseStatus = void 0;
      let responseData = void 0;
      let responseHeaders = void 0;
      const response = await fetch(url, {
        method,
        body,
        headers
      });
      responseStatus = response.status;
      responseHeaders = Object.fromEntries(response.headers.entries());
      if (response.ok) {
        responseData = await response.text();
        if ((_a = responseHeaders["content-type"]) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes("application/json")) {
          try {
            responseData = JSON.parse(responseData);
          } catch (error) {
            throw new Error("could not parse response data " + error.message);
          }
        }
      } else {
        responseData = await response.text();
      }
      return {
        status: responseStatus,
        headers: responseHeaders,
        data: responseData
      };
    }
    var UnifiedNetwork = class {
      constructor(base) {
        var _a;
        var _b;
        this.base = base !== null && base !== void 0 ? base : {};
        (_a = (_b = this.base).headers) !== null && _a !== void 0 ? _a : _b.headers = {};
      }
      async request(config) {
        var _a, _b, _c, _d;
        let { method, baseUrl, url, parameters, queries, body, processor } = Object.assign(Object.assign({}, (_a = this.base) !== null && _a !== void 0 ? _a : {}), config);
        url !== null && url !== void 0 ? url : url = "/";
        processor !== null && processor !== void 0 ? processor : processor = httpProcessorFetch;
        let fullUrl = baseUrl ? (0, util_1.joinPaths)(baseUrl, url) : url;
        if (parameters) {
          for (const key in parameters) {
            fullUrl = fullUrl.replaceAll(`[${key}]`, parameters[key]);
          }
        }
        if (queries) {
          fullUrl = fullUrl + (fullUrl.includes("?") ? "&" : "?") + Object.keys(queries).map((key) => `${key}=${queries[key]}`).join("&");
        }
        let headers = Object.assign(Object.assign({}, (_c = (_b = this.base) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {}), (_d = config.headers) !== null && _d !== void 0 ? _d : {});
        if (typeof body === "object" && body !== null) {
          body = JSON.stringify(body);
          headers["Content-Type"] = "application/json";
        }
        let responseStatus = void 0;
        let responseData = void 0;
        let responseHeaders = {};
        try {
          const { status: processorStatus, data: processorData, headers: processorHeaders } = await processor({
            url: fullUrl,
            method: method !== null && method !== void 0 ? method : "get",
            headers,
            body
          });
          responseStatus = processorStatus;
          responseHeaders = processorHeaders;
          responseData = processorData;
        } catch (error) {
          console.error(error);
          responseStatus = -1;
          responseData = void 0;
        }
        return {
          status: responseStatus,
          data: responseData,
          headers: responseHeaders
        };
      }
      async get(config) {
        return this.request(Object.assign(Object.assign({}, config), { method: "get" }));
      }
      async post(config) {
        return this.request(Object.assign(Object.assign({}, config), { method: "post" }));
      }
      async put(config) {
        return this.request(Object.assign(Object.assign({}, config), { method: "put" }));
      }
      async patch(config) {
        return this.request(Object.assign(Object.assign({}, config), { method: "patch" }));
      }
      async delete(config) {
        return this.request(Object.assign(Object.assign({}, config), { method: "delete" }));
      }
      async head(config) {
        return this.request(Object.assign(Object.assign({}, config), { method: "head" }));
      }
    };
    exports.UnifiedNetwork = UnifiedNetwork;
  }
});

// node_modules/unified-network/lib/index.js
var require_lib = __commonJS({
  "node_modules/unified-network/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeUnifiedNetwork = void 0;
    var unified_network_1 = require_unified_network();
    function makeUnifiedNetwork(base) {
      return new unified_network_1.UnifiedNetwork(base);
    }
    exports.makeUnifiedNetwork = makeUnifiedNetwork;
  }
});

// dep:unified-network
var unified_network_default = require_lib();
export {
  unified_network_default as default
};
//# sourceMappingURL=unified-network.js.map
